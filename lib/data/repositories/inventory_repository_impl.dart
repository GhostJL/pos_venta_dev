import 'package:posventa/data/datasources/database_helper.dart';
import 'package:posventa/data/models/inventory_model.dart';
import 'package:posventa/domain/entities/inventory.dart';
import 'package:posventa/domain/entities/inventory_movement.dart';
import 'package:posventa/domain/repositories/inventory_repository.dart';

class InventoryRepositoryImpl implements InventoryRepository {
  final DatabaseHelper _databaseHelper;

  InventoryRepositoryImpl(this._databaseHelper);

  @override
  Stream<List<Inventory>> getAllInventoryStream() async* {
    yield await getAllInventory();
    await for (final table in _databaseHelper.tableUpdateStream) {
      if (table == DatabaseHelper.tableInventory) {
        yield await getAllInventory();
      }
    }
  }

  @override
  Future<void> createInventory(Inventory inventory) async {
    final model = InventoryModel.fromEntity(inventory);
    final map = model.toJson();
    map.remove('id'); // Ensure ID is generated by DB

    // Remove null values to avoid SQL issues
    map.removeWhere((key, value) => value == null);

    // Set initial updated_at
    map['updated_at'] = DateTime.now().toIso8601String();

    await _databaseHelper.insert(DatabaseHelper.tableInventory, map);
    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<void> deleteInventory(int id) async {
    final db = await _databaseHelper.database;

    await db.transaction((txn) async {
      // 1. Get the inventory record details before deleting
      final result = await txn.query(
        DatabaseHelper.tableInventory,
        columns: ['product_id', 'warehouse_id', 'variant_id'],
        where: 'id = ?',
        whereArgs: [id],
      );

      if (result.isEmpty) return; // Nothing to delete

      final row = result.first;
      final productId = row['product_id'] as int;
      final warehouseId = row['warehouse_id'] as int;
      final variantId = row['variant_id'] as int?;

      // 2. Delete inventory lots associated with this inventory record
      // Logic: Delete lots for this Product + Warehouse + Variant
      // FIX: If variantId is null (valid for legacy data), we should delete ALL lots
      // for this product/warehouse to ensure we truly "Reset" the stock.
      // Otherwise, lots with specific variant IDs might persist and keep stock > 0.

      final whereClause = variantId != null
          ? 'product_id = ? AND warehouse_id = ? AND variant_id = ?'
          : 'product_id = ? AND warehouse_id = ?'; // Broad delete if variant is unknown

      final whereArgs = variantId != null
          ? [productId, warehouseId, variantId]
          : [productId, warehouseId];

      await txn.delete(
        DatabaseHelper.tableInventoryLots,
        where: whereClause,
        whereArgs: whereArgs,
      );

      // 3. Delete the inventory record itself
      await txn.delete(
        DatabaseHelper.tableInventory,
        where: 'id = ?',
        whereArgs: [id],
      );
    });

    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<void> deleteInventoryForProductVariant(
    int productId,
    int warehouseId,
    int variantId,
  ) async {
    final db = await _databaseHelper.database;

    await db.transaction((txn) async {
      // 1. Delete Lots (Strict Match for Variant)
      await txn.delete(
        DatabaseHelper.tableInventoryLots,
        where: 'product_id = ? AND warehouse_id = ? AND variant_id = ?',
        whereArgs: [productId, warehouseId, variantId],
      );

      // 2. Delete Inventory Record (Strict Match)
      await txn.delete(
        DatabaseHelper.tableInventory,
        where: 'product_id = ? AND warehouse_id = ? AND variant_id = ?',
        whereArgs: [productId, warehouseId, variantId],
      );

      // 3. Fallback: Also try deleting records with NULL variantId if this is the only variant?
      // Or handled separately? For now, strict deletion is safer for "Virtual Items" which imply specific variant context.
    });

    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<List<Inventory>> getAllInventory() async {
    final result = await _databaseHelper.queryAll(
      DatabaseHelper.tableInventory,
    );
    return result.map((e) => InventoryModel.fromJson(e)).toList();
  }

  @override
  Future<Inventory?> getInventoryById(int id) async {
    final result = await _databaseHelper.queryById(
      DatabaseHelper.tableInventory,
      id,
    );
    if (result != null) {
      return InventoryModel.fromJson(result);
    }
    return null;
  }

  @override
  Future<List<Inventory>> getInventoryByProduct(int productId) async {
    final db = await _databaseHelper.database;
    final result = await db.query(
      DatabaseHelper.tableInventory,
      where: 'product_id = ?',
      whereArgs: [productId],
    );
    return result.map((e) => InventoryModel.fromJson(e)).toList();
  }

  @override
  Future<List<Inventory>> getInventoryByWarehouse(int warehouseId) async {
    final db = await _databaseHelper.database;
    final result = await db.query(
      DatabaseHelper.tableInventory,
      where: 'warehouse_id = ?',
      whereArgs: [warehouseId],
    );
    return result.map((e) => InventoryModel.fromJson(e)).toList();
  }

  @override
  Future<void> updateInventory(Inventory inventory) async {
    final model = InventoryModel.fromEntity(inventory);
    final map = model.toJson();

    // Remove null values except for id (needed for update)
    final id = map['id'];
    map.removeWhere((key, value) => value == null);
    map['id'] = id; // Restore id

    // Update timestamp
    map['updated_at'] = DateTime.now().toIso8601String();

    await _databaseHelper.update(DatabaseHelper.tableInventory, map);
    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<void> adjustInventory(InventoryMovement movement) async {
    final db = await _databaseHelper.database;
    await db.transaction((txn) async {
      // 1. Get current inventory
      final whereClause = movement.variantId != null
          ? 'product_id = ? AND warehouse_id = ? AND variant_id = ?'
          : 'product_id = ? AND warehouse_id = ? AND variant_id IS NULL';
      final whereArgs = movement.variantId != null
          ? [movement.productId, movement.warehouseId, movement.variantId]
          : [movement.productId, movement.warehouseId];

      final inventoryResult = await txn.query(
        DatabaseHelper.tableInventory,
        where: whereClause,
        whereArgs: whereArgs,
      );

      if (inventoryResult.isEmpty) {
        // If no inventory exists, create it (assuming starting from 0)
        await txn.insert(DatabaseHelper.tableInventory, {
          'product_id': movement.productId,
          'warehouse_id': movement.warehouseId,
          'variant_id': movement.variantId,
          'quantity_on_hand': movement
              .quantity, // Initial quantity is the adjustment amount (if positive) or negative
          'quantity_reserved': 0,
          'updated_at': DateTime.now().toIso8601String(),
        });
      } else {
        // Update existing inventory
        await txn.rawUpdate(
          '''
          UPDATE ${DatabaseHelper.tableInventory}
          SET quantity_on_hand = quantity_on_hand + ?,
              updated_at = ?
          WHERE $whereClause
        ''',
          [movement.quantity, DateTime.now().toIso8601String(), ...whereArgs],
        );
      }

      // 2. Create Movement Record
      await txn.insert(DatabaseHelper.tableInventoryMovements, {
        'product_id': movement.productId,
        'warehouse_id': movement.warehouseId,
        'variant_id': movement.variantId,
        'movement_type': movement.movementType.value,
        'quantity': movement.quantity,
        'quantity_before': movement.quantityBefore,
        'quantity_after': movement.quantityAfter,
        'reference_type': movement.referenceType,
        'reference_id': movement.referenceId,
        'lot_id': movement.lotId,
        'reason': movement.reason,
        'performed_by': movement.performedBy,
        'movement_date': DateTime.now().toIso8601String(),
      });
    });
    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<void> adjustInventoryBatch(List<InventoryMovement> movements) async {
    final db = await _databaseHelper.database;
    await db.transaction((txn) async {
      for (final movement in movements) {
        // 1. Get current inventory
        final whereClause = movement.variantId != null
            ? 'product_id = ? AND warehouse_id = ? AND variant_id = ?'
            : 'product_id = ? AND warehouse_id = ? AND variant_id IS NULL';
        final whereArgs = movement.variantId != null
            ? [movement.productId, movement.warehouseId, movement.variantId]
            : [movement.productId, movement.warehouseId];

        final inventoryResult = await txn.query(
          DatabaseHelper.tableInventory,
          where: whereClause,
          whereArgs: whereArgs,
        );

        if (inventoryResult.isEmpty) {
          // If no inventory exists, create it (assuming starting from 0)
          await txn.insert(DatabaseHelper.tableInventory, {
            'product_id': movement.productId,
            'warehouse_id': movement.warehouseId,
            'variant_id': movement.variantId,
            'quantity_on_hand': movement.quantity,
            'quantity_reserved': 0,
            'updated_at': DateTime.now().toIso8601String(),
          });
        } else {
          // Update existing inventory
          await txn.rawUpdate(
            '''
            UPDATE ${DatabaseHelper.tableInventory}
            SET quantity_on_hand = quantity_on_hand + ?,
                updated_at = ?
            WHERE $whereClause
          ''',
            [movement.quantity, DateTime.now().toIso8601String(), ...whereArgs],
          );
        }

        // 2. Create Movement Record
        await txn.insert(DatabaseHelper.tableInventoryMovements, {
          'product_id': movement.productId,
          'warehouse_id': movement.warehouseId,
          'variant_id': movement.variantId,
          'movement_type': movement.movementType.value,
          'quantity': movement.quantity,
          'quantity_before': movement.quantityBefore,
          'quantity_after': movement.quantityAfter,
          'reference_type': movement.referenceType,
          'reference_id': movement.referenceId,
          'lot_id': movement.lotId,
          'reason': movement.reason,
          'performed_by': movement.performedBy,
          'movement_date': DateTime.now().toIso8601String(),
        });
      }
    });
    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }

  @override
  Future<void> transferInventory({
    required int fromWarehouseId,
    required int toWarehouseId,
    required int productId,
    required double quantity,
    required int userId,
    String? reason,
  }) async {
    final db = await _databaseHelper.database;
    await db.transaction((txn) async {
      // --- 1. Handle Source Warehouse (OUT) ---

      // Check source inventory
      final sourceInvResult = await txn.query(
        DatabaseHelper.tableInventory,
        where: 'product_id = ? AND warehouse_id = ?',
        whereArgs: [productId, fromWarehouseId],
      );

      if (sourceInvResult.isEmpty) {
        throw Exception('Source inventory not found');
      }

      final sourceQtyBefore = (sourceInvResult.first['quantity_on_hand'] as num)
          .toDouble();
      if (sourceQtyBefore < quantity) {
        throw Exception('Insufficient stock in source warehouse');
      }

      // Deduct from source
      await txn.rawUpdate(
        '''
        UPDATE ${DatabaseHelper.tableInventory}
        SET quantity_on_hand = quantity_on_hand - ?,
            updated_at = ?
        WHERE product_id = ? AND warehouse_id = ?
      ''',
        [
          quantity,
          DateTime.now().toIso8601String(),
          productId,
          fromWarehouseId,
        ],
      );

      // Record OUT movement
      await txn.insert(DatabaseHelper.tableInventoryMovements, {
        'product_id': productId,
        'warehouse_id': fromWarehouseId,
        'movement_type': 'transfer_out',
        'quantity': -quantity,
        'quantity_before': sourceQtyBefore,
        'quantity_after': sourceQtyBefore - quantity,
        'reference_type': 'transfer',
        // 'reference_id': transferId, // If we had a transfer table
        'reason': reason ?? 'Transfer to Warehouse $toWarehouseId',
        'performed_by': userId,
        'movement_date': DateTime.now().toIso8601String(),
      });

      // --- 2. Handle Destination Warehouse (IN) ---

      // Check/Create destination inventory
      final destInvResult = await txn.query(
        DatabaseHelper.tableInventory,
        where: 'product_id = ? AND warehouse_id = ?',
        whereArgs: [productId, toWarehouseId],
      );

      double destQtyBefore = 0;
      if (destInvResult.isEmpty) {
        await txn.insert(DatabaseHelper.tableInventory, {
          'product_id': productId,
          'warehouse_id': toWarehouseId,
          'quantity_on_hand': quantity,
          'quantity_reserved': 0,
          'updated_at': DateTime.now().toIso8601String(),
        });
      } else {
        destQtyBefore = (destInvResult.first['quantity_on_hand'] as num)
            .toDouble();
        await txn.rawUpdate(
          '''
          UPDATE ${DatabaseHelper.tableInventory}
          SET quantity_on_hand = quantity_on_hand + ?,
              updated_at = ?
          WHERE product_id = ? AND warehouse_id = ?
        ''',
          [
            quantity,
            DateTime.now().toIso8601String(),
            productId,
            toWarehouseId,
          ],
        );
      }

      // Record IN movement
      await txn.insert(DatabaseHelper.tableInventoryMovements, {
        'product_id': productId,
        'warehouse_id': toWarehouseId,
        'movement_type': 'transfer_in',
        'quantity': quantity,
        'quantity_before': destQtyBefore,
        'quantity_after': destQtyBefore + quantity,
        'reference_type': 'transfer',
        // 'reference_id': transferId,
        'reason': reason ?? 'Transfer from Warehouse $fromWarehouseId',
        'performed_by': userId,
        'movement_date': DateTime.now().toIso8601String(),
      });
    });
    _databaseHelper.notifyTableChanged(DatabaseHelper.tableInventory);
  }
}
