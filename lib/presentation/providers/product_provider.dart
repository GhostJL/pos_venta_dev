import 'package:posventa/domain/entities/product.dart';
import 'package:posventa/domain/entities/product_tax.dart';
import 'package:posventa/presentation/providers/providers.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'product_provider.g.dart';

@riverpod
class ProductList extends _$ProductList {
  @override
  Future<List<Product>> build() async {
    final getAllProducts = ref.watch(getAllProductsProvider);
    return getAllProducts();
  }

  Future<void> searchProducts(String query) async {
    if (query.isEmpty) {
      ref.invalidateSelf();
      return;
    }
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final searchProducts = ref.read(searchProductsProvider);
      return searchProducts(query);
    });
  }

  Future<void> addProduct(Product product) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(createProductProvider).call(product);
      return ref.read(getAllProductsProvider).call();
    });
  }

  Future<void> updateProduct(Product product) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(updateProductProvider).call(product);
      return ref.read(getAllProductsProvider).call();
    });
  }

  Future<void> deleteProduct(int id) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(deleteProductProvider).call(id);
      return ref.read(getAllProductsProvider).call();
    });
  }

  Future<void> toggleProductActive(int productId) async {
    final currentState = state.asData?.value;
    if (currentState == null) return;

    try {
      final product = currentState.firstWhere((p) => p.id == productId);
      final updatedProduct = product.copyWith(isActive: !product.isActive);
      await updateProduct(updatedProduct);
    } catch (e) {
      // Handle error or rethrow
      rethrow;
    }
  }
}

// Alias for backward compatibility if needed, though usage should be updated to productListProvider
// Note: productListProvider is generated by riverpod_generator from ProductList class
final productNotifierProvider = productListProvider;

extension ProductCopyWith on Product {
  Product copyWith({
    int? id,
    String? code,
    String? barcode,
    String? name,
    String? description,
    int? departmentId,
    int? categoryId,
    int? brandId,
    int? supplierId,
    String? unitOfMeasure,
    bool? isSoldByWeight,
    int? costPriceCents,
    int? salePriceCents,
    int? wholesalePriceCents,
    bool? isActive,
    List<ProductTax>? productTaxes,
  }) {
    return Product(
      id: id ?? this.id,
      code: code ?? this.code,
      barcode: barcode ?? this.barcode,
      name: name ?? this.name,
      description: description ?? this.description,
      departmentId: departmentId ?? this.departmentId,
      categoryId: categoryId ?? this.categoryId,
      brandId: brandId ?? this.brandId,
      supplierId: supplierId ?? this.supplierId,
      unitOfMeasure: unitOfMeasure ?? this.unitOfMeasure,
      isSoldByWeight: isSoldByWeight ?? this.isSoldByWeight,
      costPriceCents: costPriceCents ?? this.costPriceCents,
      salePriceCents: salePriceCents ?? this.salePriceCents,
      wholesalePriceCents: wholesalePriceCents ?? this.wholesalePriceCents,
      isActive: isActive ?? this.isActive,
      productTaxes: productTaxes ?? this.productTaxes,
    );
  }
}
