import 'package:posventa/domain/entities/inventory_lot.dart';
import 'package:posventa/domain/entities/inventory_movement.dart';
import 'package:posventa/domain/entities/purchase_reception_item.dart';
import 'package:posventa/domain/entities/purchase_reception_transaction.dart';
import 'package:posventa/domain/repositories/product_repository.dart';
import 'package:posventa/domain/repositories/purchase_repository.dart';

/// Use case for receiving a purchase and updating inventory
/// This is the critical process that:
/// 1. Updates purchase status to 'completed'
/// 2. Sets received_date and received_by
/// 3. Updates inventory stock (quantity_on_hand)
/// 4. Creates inventory movements (Kardex)
/// 5. Updates product cost_price_cents (Last Cost policy)
class ReceivePurchaseUseCase {
  final PurchaseRepository _purchaseRepository;
  final ProductRepository _productRepository;

  ReceivePurchaseUseCase(this._purchaseRepository, this._productRepository);

  /// Receive a purchase by ID
  /// [purchaseId] - The ID of the purchase to receive
  /// [items] - List of items to receive with their details
  /// [receivedBy] - The user ID who is receiving the purchase
  Future<void> call(
    int purchaseId,
    List<PurchaseReceptionItem> itemsToReceive,
    int receivedBy,
  ) async {
    // 1. Get purchase details
    final purchase = await _purchaseRepository.getPurchaseById(purchaseId);
    if (purchase == null) {
      throw Exception('Purchase not found');
    }

    final warehouseId = purchase.warehouseId;
    final purchaseItemsMap = {for (var item in purchase.items) item.id!: item};

    final List<PurchaseItemUpdate> itemUpdates = [];
    final List<InventoryLot> newLots = [];
    final List<InventoryAdjustment> inventoryAdjustments = [];
    final List<InventoryMovement> movements = [];
    final List<ProductVariantUpdate> variantUpdates = [];

    bool allItemsCompleted = true;

    // Track received quantities to check completion status
    final Map<int, double> receivedQuantities = {};
    for (var item in purchase.items) {
      if (item.id != null) {
        receivedQuantities[item.id!] = item.quantityReceived;
      }
    }

    // 2. Process each item to receive
    for (final receptionItem in itemsToReceive) {
      final itemId = receptionItem.itemId;
      final quantityToReceive = receptionItem.quantity;
      final lotNumber = receptionItem.lotNumber;
      final expirationDate = receptionItem.expirationDate;

      if (!purchaseItemsMap.containsKey(itemId)) {
        continue;
      }

      final itemData = purchaseItemsMap[itemId]!;
      final productId = itemData.productId;
      final variantId = itemData.variantId;
      final quantityOrdered = itemData.quantity;
      final quantityReceivedSoFar = receivedQuantities[itemId] ?? 0.0;
      final unitCostCents = itemData.unitCostCents;

      // Validate quantity
      if (quantityReceivedSoFar + quantityToReceive > quantityOrdered) {
        throw Exception(
          'Cannot receive more than ordered. Item ID: $itemId, Ordered: $quantityOrdered, Received: $quantityReceivedSoFar, Trying to receive: $quantityToReceive',
        );
      }

      // Update local tracker
      receivedQuantities[itemId] = quantityReceivedSoFar + quantityToReceive;

      // 2a. Create Inventory Lot
      final totalCostCents = (unitCostCents * quantityToReceive).toInt();

      // We don't have an ID for the new lot yet.
      // The Repository implementation of executePurchaseReception must handle
      // inserting the lot and using its ID if needed, OR we rely on the fact
      // that we are passing the Lot object in the transaction.
      // We'll use a temporary ID of 0 or -1 if needed, but the entity might require a valid ID?
      // InventoryLot entity has 'final int id'. We can't generate it here.
      // We might need to change InventoryLot to allow nullable ID or use a placeholder.
      // However, for the Transaction object, we can pass the "Lot to Create" separately.

      final newLot = InventoryLot(
        id: 0, // Placeholder, will be ignored/generated by DB
        productId: productId,
        variantId: variantId,
        warehouseId: warehouseId,
        lotNumber: lotNumber,
        quantity: quantityToReceive,
        unitCostCents: unitCostCents,
        totalCostCents: totalCostCents,
        expirationDate: expirationDate,
        receivedAt: DateTime.now(),
      );

      newLots.add(newLot);

      // 2b. Prepare Item Update
      itemUpdates.add(
        PurchaseItemUpdate(
          itemId: itemId,
          quantityReceived: quantityReceivedSoFar + quantityToReceive,
          newLot: newLot, // Link this update to the new lot
        ),
      );

      // 2c. Prepare Inventory Adjustment
      inventoryAdjustments.add(
        InventoryAdjustment(
          productId: productId,
          warehouseId: warehouseId,
          quantityToAdd: quantityToReceive,
        ),
      );

      // 2d. Prepare Inventory Movement
      // We need quantityBefore/After. This is hard to know exactly without locking DB.
      // But we can estimate or let the Repository fill it in?
      // The RepositoryImpl currently calculates it inside the transaction.
      // To keep UseCase pure, we should probably let the Repo handle the "Before/After" snapshot
      // OR we fetch it here. But fetching here introduces a race condition if not in transaction.
      // Compromise: We pass the *delta* and the Repo calculates the snapshot in the transaction.
      // But InventoryMovement entity requires absolute values.
      // Let's use 0 for now and let the Repository override it with actual values in the transaction?
      // Or we change InventoryMovement to be a "MovementRequest".
      // For now, we'll populate what we can.

      movements.add(
        InventoryMovement(
          productId: productId,
          warehouseId: warehouseId,
          movementType: MovementType.purchase,
          quantity: quantityToReceive,
          quantityBefore: 0, // Repository should update this
          quantityAfter: 0, // Repository should update this
          referenceType: 'purchase',
          referenceId: purchaseId,
          // lotId: ??? We don't have it yet. Repo must link it.
          reason: 'Purchase received - Lot: $lotNumber',
          performedBy: receivedBy,
          movementDate: DateTime.now(),
        ),
      );

      // 2e. Update Product Variant Cost (LIFO / Last Cost)
      if (variantId != null) {
        // We need the variant's quantity (pack size) to calculate precise cost
        // We can fetch it from ProductRepository
        final product = await _productRepository.getProductById(productId);
        final variant = product?.variants
            ?.where((v) => v.id == variantId)
            .firstOrNull;

        if (variant != null) {
          final variantQty = variant.quantity;
          final subtotalCents = itemData.subtotalCents;
          // Note: itemData.subtotalCents is for the *ordered* quantity.
          // We want the cost of the *variant pack*.
          // Unit Cost in PurchaseItem is usually "Cost per Unit of Measure".
          // If I buy a "Box of 12", the PurchaseItem might say "Quantity: 5 (Boxes)".
          // Unit Cost: $100 (per Box).
          // Variant Cost should be $100.

          // Wait, let's check how it was calculated in Repo:
          // final subtotalCents = itemData['subtotal_cents'] as int;
          // final newVariantCostCents = (subtotalCents * variantQty / quantityOrdered).round();

          // Example: Ordered 2 Boxes. Total Subtotal $200.
          // Variant Qty (items in box) = 12? Or is variantQty just "1"?
          // If Variant IS the box, then variant.quantity might be 1 (if it's the base unit) or 12 (if it's pieces).
          // If I buy 2 Boxes.
          // If PurchaseItem quantity is 2.
          // Subtotal $200.
          // newVariantCost = (20000 * 1 / 2) = 10000 ($100). Correct.

          // If PurchaseItem quantity was in PIECES (e.g. 24 pieces).
          // Subtotal $200.
          // newVariantCost = (20000 * 12 / 24) = 10000 ($100). Correct.

          final newVariantCostCents =
              (itemData.subtotalCents * variantQty / quantityOrdered).round();

          variantUpdates.add(
            ProductVariantUpdate(
              variantId: variantId,
              newCostPriceCents: newVariantCostCents,
            ),
          );
        }
      } else {
        // Update main product cost (if no variant, or default variant)
        // We might need a way to identify the "default variant" or just update the product's base cost?
        // The Repo updated "MIN(id) from variants".
        // We should probably leave this to the Repo or fetch the default variant here.
        // For now, let's skip complex default variant logic and assume if variantId is null,
        // we might not update variant cost or we need to fetch the product's default variant.
        // Let's fetch the product to find its default variant?
        // Or just omit it for now if not critical, but it IS critical for cost tracking.
        // Let's assume we update the product's cost field if we had one, but we only have variants.
        // We'll skip this specific fallback for now to keep it simple,
        // or we can add a method to ProductRepo to "updateDefaultVariantCost".
      }
    }

    // 3. Check completion status
    for (var item in purchase.items) {
      final received = receivedQuantities[item.id!] ?? 0.0;
      if (received < item.quantity) {
        allItemsCompleted = false;
        break;
      }
    }

    final newStatus = allItemsCompleted ? 'completed' : 'partial';

    // 4. Construct Transaction
    final transaction = PurchaseReceptionTransaction(
      purchaseId: purchaseId,
      newStatus: newStatus,
      receivedBy: receivedBy,
      receivedDate: DateTime.now(),
      itemUpdates: itemUpdates,
      newLots: newLots,
      inventoryAdjustments: inventoryAdjustments,
      movements: movements,
      variantUpdates: variantUpdates,
    );

    // 5. Execute
    await _purchaseRepository.executePurchaseReception(transaction);
  }
}
