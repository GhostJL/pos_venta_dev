import 'package:posventa/domain/entities/product.dart';
import 'package:posventa/domain/entities/product_tax.dart';
import 'package:posventa/domain/entities/product_variant.dart';
import 'package:posventa/presentation/providers/providers.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

part 'product_provider.g.dart';

@riverpod
class ProductSearchQuery extends _$ProductSearchQuery {
  @override
  String build() {
    return '';
  }

  void setQuery(String query) {
    state = query;
  }
}

@riverpod
class ProductList extends _$ProductList {
  @override
  Stream<List<Product>> build() {
    final query = ref.watch(productSearchQueryProvider);

    if (query.isEmpty) {
      final getAllProducts = ref.watch(getAllProductsProvider);
      return getAllProducts.stream().map(
        (either) => either.fold(
          (failure) =>
              throw failure.message, // Failures create AsyncError in UI
          (products) => products,
        ),
      );
    } else {
      // For search, we can still use a Future converted to Stream,
      // or if search supports streaming, use that.
      // Usually search is a one-off query, so Future is fine.
      return Stream.fromFuture(_searchProducts(query));
    }
  }

  Future<List<Product>> _searchProducts(String query) async {
    final searchProducts = ref.read(searchProductsProvider);
    final result = await searchProducts.call(query);
    return result.fold(
      (failure) => throw failure.message,
      (products) => products,
    );
  }

  void searchProducts(String query) {
    ref.read(productSearchQueryProvider.notifier).setQuery(query);
  }

  Future<void> addProduct(Product product) async {
    final result = await ref.read(createProductProvider).call(product);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> updateProduct(Product product) async {
    final result = await ref.read(updateProductProvider).call(product);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> deleteProduct(int id) async {
    final result = await ref.read(deleteProductProvider).call(id);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> toggleActive(int productId, bool isActive) async {
    final currentState = state.value;
    if (currentState == null) return;

    try {
      final product = currentState.firstWhere((p) => p.id == productId);
      // Only update if changed prevents unnecessary writes, but UI might be optimistic
      if (product.isActive != isActive) {
        final updatedProduct = product.copyWith(isActive: isActive);
        await updateProduct(updatedProduct);
      }
    } catch (e) {
      // If product not found in current list (e.g. search filter), fetch it or ignore.
      // Usually it should be in the list if we clicked it.
      rethrow;
    }
  }
}

// Alias for backward compatibility if needed, though usage should be updated to productListProvider
// Note: productListProvider is generated by riverpod_generator from ProductList class
final productNotifierProvider = productListProvider;

extension ProductCopyWith on Product {
  Product copyWith({
    int? id,
    String? code,
    String? name,
    String? description,
    int? departmentId,
    int? categoryId,
    int? brandId,
    int? supplierId,
    bool? isSoldByWeight,
    bool? isActive,
    List<ProductTax>? productTaxes,
    List<ProductVariant>? variants,
  }) {
    return Product(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      departmentId: departmentId ?? this.departmentId,
      categoryId: categoryId ?? this.categoryId,
      brandId: brandId ?? this.brandId,
      supplierId: supplierId ?? this.supplierId,
      isSoldByWeight: isSoldByWeight ?? this.isSoldByWeight,
      isActive: isActive ?? this.isActive,
      productTaxes: productTaxes ?? this.productTaxes,
      variants: variants ?? this.variants,
    );
  }
}

final productProvider = FutureProvider.family<Product?, int>((ref, id) async {
  final result = await ref.watch(productRepositoryProvider).getProductById(id);
  return result.fold((failure) => throw failure.message, (product) => product);
});
