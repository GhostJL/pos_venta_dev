import 'package:posventa/domain/entities/product.dart';
import 'package:posventa/domain/entities/product_tax.dart';
import 'package:posventa/domain/entities/product_variant.dart';
import 'package:posventa/presentation/providers/providers.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:posventa/presentation/providers/auth_provider.dart';

part 'product_provider.g.dart';

@Riverpod(keepAlive: true)
class ProductSearchQuery extends _$ProductSearchQuery {
  @override
  String build() {
    return '';
  }

  void setQuery(String query) {
    state = query;
  }
}

@Riverpod(keepAlive: true)
class ProductList extends _$ProductList {
  @override
  @override
  Future<List<Product>> build() async {
    final query = ref.watch(productSearchQueryProvider);

    // Listen for database updates to invalidate cache
    // We access the stream via the repository's dataSource (indirectly) or global provider.
    // Assuming tableUpdateStreamProvider is available from core_di or similar.
    // If not, we can watch the repository updates if exposed?
    // Repository removed the stream.
    // Let's use a polling or event bus approach if needed, but for now
    // let's try to find tableUpdateStreamProvider.
    // Current workaround: We will just fetch. Real-time updates for THIS legacy provider
    // might be compromised until we wire up the listener correctly.
    // However, the User Plan says: "We will listen to tableUpdateStream".
    // I will assume it's `tableUpdateStreamProvider`.

    final searchProducts = ref.watch(searchProductsProvider);

    // If query is present, search.
    // Optimization: If query is empty, limit to 50 items to prevent loading 1000+ items
    final result = await searchProducts.call(
      query,
      limit: query.isEmpty ? 50 : null,
    );

    return result.fold(
      (failure) => throw failure.message,
      (products) => products,
    );
  }

  // _searchProducts is no longer needed for internal logic if we use stream
  // BUT we leaving it or removing it? remove it.

  void searchProducts(String query) {
    ref.read(productSearchQueryProvider.notifier).setQuery(query);
  }

  Future<void> addProduct(Product product) async {
    final userId = ref.read(authProvider).user?.id;
    if (userId == null) throw "Authenticated user required for audit";
    final result = await ref
        .read(createProductProvider)
        .call(product, userId: userId);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> updateProduct(Product product) async {
    final userId = ref.read(authProvider).user?.id;
    if (userId == null) throw "Authenticated user required for audit";
    final result = await ref
        .read(updateProductProvider)
        .call(product, userId: userId);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> deleteProduct(int id) async {
    final userId = ref.read(authProvider).user?.id;
    if (userId == null) throw "Authenticated user required for audit";
    final result = await ref
        .read(deleteProductProvider)
        .call(id, userId: userId);
    result.fold((failure) => throw failure.message, (success) => null);
    // Stream will auto-update if it's watching the DB
  }

  Future<void> toggleActive(Product product) async {
    try {
      final updatedProduct = product.copyWith(isActive: !product.isActive);
      await updateProduct(updatedProduct);
    } catch (e) {
      rethrow;
    }
  }
}

// Alias for backward compatibility if needed, though usage should be updated to productListProvider
// Note: productListProvider is generated by riverpod_generator from ProductList class
final productNotifierProvider = productListProvider;

extension ProductCopyWith on Product {
  Product copyWith({
    int? id,
    String? code,
    String? name,
    String? description,
    int? departmentId,
    int? categoryId,
    int? brandId,
    int? supplierId,
    bool? isSoldByWeight,
    bool? isActive,
    List<ProductTax>? productTaxes,
    List<ProductVariant>? variants,
  }) {
    return Product(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      departmentId: departmentId ?? this.departmentId,
      categoryId: categoryId ?? this.categoryId,
      brandId: brandId ?? this.brandId,
      supplierId: supplierId ?? this.supplierId,
      isSoldByWeight: isSoldByWeight ?? this.isSoldByWeight,
      isActive: isActive ?? this.isActive,
      productTaxes: productTaxes ?? this.productTaxes,
      variants: variants ?? this.variants,
    );
  }
}

final productProvider = FutureProvider.family<Product?, int>((ref, id) async {
  final result = await ref.watch(productRepositoryProvider).getProductById(id);
  return result.fold((failure) => throw failure.message, (product) => product);
});
